---
--- Generated by lua-serialize(https://github.com/limao996/lua-serialize)
--- Created by 狸猫呐.
--- DateTime: 2023/6/25 19:30
---

local pack, unpack = string.pack, string.unpack
local type, load
, next = type, load, next
local math_type, string_dump,
table_concat, table_insert = math.type, string.dump, table.concat, table.insert

---@class Serialize
local _M = {}

--- 计算数值占用字节数
---@private
---@param n number 数值
---@return number 字节数
local function get_int_size(n)
    local b = 0
    for i = 1, 32 do
        b = (b << 8) + 255
        if n <= b then
            return i
        end
    end
end

--- 打包数据
---@private
---@param v any 数据
---@return string
local function _pack(v)
    local tp = type(v)
    if tp == 'string' then
        local b = get_int_size(#v)
        tp = 10 + b
        return pack('<Bs' .. b, tp, v)
    elseif math_type(v) == 'integer' then
        local u = 10
        if v < 0 then
            u = 20
            v = -v
        end
        local b = get_int_size(v)
        tp = 200 + u + b
        return pack('<BI' .. b, tp, v)
    elseif tp == 'number' then
        tp = 20
        return pack('<Bn', tp, v)
    elseif tp == 'boolean' then
        tp = 30 + (v and 1 or 0)
        return pack('<B', tp)
    elseif tp == 'function' then
        v = string_dump(v, true)
        local b = get_int_size(#v)
        tp = 40 + b
        return pack('<Bs' .. b, tp, v)
    end
end

--- 解包数据
---@private
---@param data string 数据
---@param pos number 位置
---@return number, any, number 类型, 数据, 位置
local function _unpack(data, pos)
    tp, a = unpack('<B', data, pos)
    pos = pos + 1
    if tp >= 10 and tp < 20 then
        local b = tp - 10
        v = unpack('<s' .. b, data, pos)
        pos = pos + b + #v
    elseif tp == 20 then
        v = unpack('<n', data, pos)
        pos = pos + 8
    elseif tp >= 210 and tp < 220 then
        local b = tp - 210
        v = unpack('<I' .. b, data, pos)
        pos = pos + b
    elseif tp >= 220 and tp < 230 then
        local b = tp - 220
        v = -unpack('<I' .. b, data, pos)
        pos = pos + b
    elseif tp >= 30 and tp < 40 then
        local b = tp - 30
        v = b == 1
    elseif tp >= 40 and tp < 50 then
        local b = tp - 40
        local s = unpack('<s' .. b, data, pos)
        v = load(s)
        pos = pos + b + #s
    end
    return tp, v, pos
end

local SOT = 0
local INDEX = 1
local KEY = 2
local VALUE = 3
local EOT = 4

---@private
---@class NodeState
---@field key any
---@field value any
---@field index number
---@field state number|"SOT"|"INDEX"|"KEY"|"VALUE"|"EOT"

--- 序列化
---@param data any 源数据
---@return string 目标数据
function _M.serialize(data)
    local last_state ---@type NodeState 状态栈顶
    local last_node ---@type any 节点栈顶
    local buffer = {} ---@type string[] 缓冲区
    local node_stack = { data } ---@type any[] 节点栈
    local state_stack = { { state = SOT } } ---@type NodeState[] 状态栈
    local buffer_length = 0 ---@type number 缓冲区长度
    local node_count = #node_stack ---@type number 节点数量

    -- 空栈即结束
    while node_count > 0 do
        -- 取栈顶
        last_node = node_stack[node_count]
        last_state = state_stack[node_count]
        do
            -- 打包节点，非数据节点返回nil
            local res = _pack(last_node)
            -- 移入缓冲区并出栈
            if res ~= nil then
                buffer_length = buffer_length + 1
                buffer[buffer_length] = res
                node_stack[node_count] = nil
                state_stack[node_count] = nil
                node_count = node_count - 1
                goto pass
            end
        end

        if last_state.state == SOT then -- 初始化节点
            -- 写入头部
            buffer_length = buffer_length + 1
            buffer[buffer_length] = pack('<B', 51)
            -- 迭代
            local k, v = next(last_node, last_state.key)
            last_state.key = k
            last_state.value = v
            last_state.state = INDEX -- 改变状态
        end

        if last_state.state == INDEX then              -- 进入INDEX状态
            last_state.index = last_state.index or 1   -- 初始化索引计数器
            if last_state.key == last_state.index then -- 连续索引
                -- 入栈
                node_count = node_count + 1
                node_stack[node_count] = last_state.value
                state_stack[node_count] = { state = SOT }
                -- 迭代
                local k, v = next(last_node, last_state.key)
                last_state.key = k
                last_state.value = v
                -- 索引计数
                last_state.index = last_state.index + 1
                goto pass
            end
            -- 索引中断，进入字典区
            buffer_length = buffer_length + 1
            buffer[buffer_length] = pack('<B', 52)
            last_state.state = KEY -- 改变状态
        end

        if last_state.state == KEY then   -- 进入KEY状态
            if last_state.key == nil then -- 节点死亡
                -- 写入尾部并出栈
                buffer_length = buffer_length + 1
                buffer[buffer_length] = pack('<B', 53)
                node_stack[node_count] = nil
                state_stack[node_count] = nil
                node_count = node_count - 1
                goto pass
            end
            -- 入栈
            node_count = node_count + 1
            node_stack[node_count] = last_state.key
            state_stack[node_count] = { key = last_state.key, value = last_state.value, state = SOT }
            last_state.state = VALUE          -- 改变状态
        elseif last_state.state == VALUE then -- 进入VALUE状态
            -- 入栈
            node_count = node_count + 1
            node_stack[node_count] = last_state.value
            -- 迭代
            local k, v = next(last_node, last_state.key)
            last_state.key = k
            last_state.value = v
            state_stack[node_count] = { state = SOT }
            last_state.state = KEY -- 改变状态
        end
        ::pass::
    end
    return table_concat(buffer)
end

--- 反序列化
---@param data string 二进制数据
---@param pos number 数据位置
---@return any, number 数据, 位置
function _M.deserialize(data, pos)
    local init_pos = pos or 1 ---@type number 初始位置
    local node_stack = {} ---@type any[] 节点栈
    local state_stack = {} ---@type NodeState[] 状态栈
    local node_count = 0 ---@type number 节点数量
    pos = init_pos -- 位置

    if pos > #data then return nil, pos end

    -- 栈底节点死亡即结束
    while pos == init_pos or state_stack[1].state ~= EOT do
        -- 取栈顶
        local last_node = node_stack[node_count] ---@type any 节点栈顶
        local last_state = state_stack[node_count] ---@type NodeState 状态栈顶
        local tp ---@type number 类型
        local v ---@type any 值

        if last_state and last_state.state == EOT then -- 节点死亡
            -- 出栈
            state_stack[node_count] = nil
            node_stack[node_count] = nil
            node_count = node_count - 1
            -- 取出新栈顶
            local node = node_stack[node_count]
            local state = state_stack[node_count]
            -- 赋值给上一级节点
            if state.state == INDEX then
                node[#node + 1] = last_node
            elseif state.state == KEY then
                state.key = last_node
                state.state = VALUE
            elseif state.state == VALUE then
                node[state.key] = last_node
                state.state = KEY
            end
            goto pass
        end

        tp, v, pos = _unpack(data, pos) -- 解包
        if tp == 51 then                -- table节点入栈
            node_count = node_count + 1
            node_stack[node_count] = {}
            state_stack[node_count] = { state = INDEX }
        elseif tp == 52 then -- 切换字典区
            last_state.state = KEY
        elseif tp == 53 then -- 杀死节点
            last_state.state = EOT
        else                 -- 非table节点直接入栈
            node_count = node_count + 1
            node_stack[node_count] = v
            state_stack[node_count] = { state = EOT }
        end

        ::pass::
    end

    return node_stack[1], pos
end

return _M
